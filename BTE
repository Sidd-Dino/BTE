#!/usr/bin/env bash
#
#  ______   __       ______    
# /\  == \ /\ \     /\  ___\   
# \ \  __< \ \ \____\ \  __\   
#  \ \_____\\ \_____\\ \_____\ 
#   \/_____/ \/_____/ \/_____/ 
#
# Bash Text Editor
# cos.... Why the fuck not?

# Terminal Functions
###############################################################################
setup_terminal() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Setup the terminal for the TUI.
    # '\e[?1049h': Use alternative screen buffer.
    # '\e[?7l':    Disable line wrapping.
    # '\e[?25l':   Hide the cursor.
    # '\e[2J':     Clear the screen.
    # '\e[1;Nr':   Limit scrolling to scrolling area.
    #              Also sets cursor to (0,0).
    printf '\e[?1049h\e[?7l\e[2J\e[1;%sr' "$max_lines"

    # Hide echoing of user input
    stty -echo
}

reset_terminal() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Reset the terminal to a useable state (undo all changes).
    # '\e[?7h':   Re-enable line wrapping.
    # '\e[?25h':  Unhide the cursor.
    # '\e[2J':    Clear the terminal.
    # '\e[;r':    Set the scroll region to its default value.
    #             Also sets cursor to (0,0).
    # '\e[?1049l: Restore main screen buffer.
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'

    # Show user input.
    stty echo
}

clear_screen() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Only clear the scrolling window (dir item list).
    # '\e[%sH':    Move cursor to bottom of scroll area.
    # '\e[9999C':  Move cursor to right edge of the terminal.
    # '\e[1J':     Clear screen to top left corner (from cursor up).
    # '\e[2J':     Clear screen fully (if using tmux) (fixes clear issues).
    # '\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.
    #              Also sets cursor to (0,0).
    printf '\e[%sH\e[9999C\e[1J%b\e[1;%sr' \
           "$((LINES-2))" "${TMUX:+\e[2J}" "$max_lines"
}

get_term_size() {
    #* Code yoinked from fff( https://github.com/dylanaraps/fff )
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably across all bash versions in pure bash.
    read -r LINES COLUMNS < <(stty size)

    # Max list items that fit in the scroll area.
    ((max_lines=LINES-3))
}

# BTE functions
###############################################################################
status_line() {
    # '\e7'        Save cursor position.
    #              This is more widely supported than '\e[s'.
    # '\e[%sH'     Move cursor to bottom of the terminal.
    # '\e[30;41m'  Set foreground and background colors.
    # '%*s'        Insert enough spaces to fill the screen width.
    #              This sets the background color to the whole line
    #              and fixes issues in 'screen' where '\e[K' doesn't work.
    # '\r'         Move cursor back to column 0 (was at EOL due to above).
    # '\e[m'       Reset text formatting.
    # '\e[%sH\e[K' Clear line below status_line.
    # '\e8'        Restore cursor position.
    #              This is more widely supported than '\e[u'.

    printf "\e7\e[%sH\e[30;42m%*s\r%s\e[m\e[%sH\e[K\e8"\
            "$((LINES-1))" \
            "$COLUMNS" "" \
            "($((y+1))/$total_lines)"\
            "$LINES"

}

draw_line() {
    # BTE doesnt wrap lines. Hence it has to
    # display part of a line depending on the
    # x position.
    #
    # There are 4 possible cases that need to be handled
    # to display a line properly.
    #
    #             COLUMNS
    #     |<--------------------->|
    #   I 1234567890
    #  II 123456789012345678901234>
    # III <23456789012345678901234>
    #  IV <234567890
    #
    # Where COLUMNS is terminal width
    #
    # Case I:
    #       The length of the line is smaller than or equal
    #       to the COLUMNS
    #
    # Case II:
    #       The length of the line is greater than the
    #       COLUMNS and
    #       The x position of at which the cursor is ,
    #       is smaller than (COLUMNS-2).
    #
    # Case III:
    #       The length of the line is greater than the
    #       terminal width and the x position is somewhere
    #       in the middle of the line
    #
    # Case IV:
    #       The length of the line is greater than the
    #       terminal width but the x position is near
    #       the end of the line
    #

    local curr=$y

    [[ -n $1 ]] && {
        curr=$*
    }

    # \e[2K : Clear current line
    # \r    : Move cursor back to column 0 (was at EOL due to above).
    printf '\e[2K\r'

    # Case I
    # Just print the entire line
    if (( ${#file_data[curr]} <= COLUMNS )); then
        printf "%s" "${file_data[curr]}"

    # Case II
    elif (( curr != y || x < (COLUMNS-2) )); then
            printf "%s\e[30;41m%s\e[m" \
                    "${file_data[curr]:0:$((COLUMNS-1))}"\
                    ">"
    else
        local p=$(( (x-COLUMNS+2) / (COLUMNS-5) ))
        local x_start=$(( ( p*(COLUMNS-5) )+(COLUMNS-2) ))
        local x_end=$(( x_start+COLUMNS-5 ))

        # Case III
        if (( ${#file_data[curr]} < x_end )); then
            printf "\e[30;41m%s\e[m%s" \
                    "<" \
                    "${file_data[curr]:$((x_start-2)):$x_end}"

        # Case IV
        else
            printf "\e[30;41m%s\e[m%s\e[30;41m%s\e[m" \
                    "<" \
                    "${file_data[curr]:$((x_start-2)):$((x_end+1))}" \
                    ">"
        fi
    fi
}

draw_page() {
    local old_max_lines=$((y_end-y_start))
    local diff=$((max_lines-old_max_lines))

    # Screen size has decreased
    if (( diff < 0 )); then
        # If the cursor postition is within the scrolling area
        (( scroll_y <= max_lines )) && {
            y_end=$((max_lines+y_start))
        }

        # If the cursor position is outside of the scrolling area
        (( scroll_y > max_lines )) && {
            scroll_y=$((max_lines))
            y_end=$((y+1))
            y_start=$((y_end-max_lines))
        }

    # Screen size has increased
    elif (( diff > 0 )); then

        # If the files length is bigger than scroll area
        (( total_lines > max_lines )) && {
            local top_offset=$((diff/2))
            local bot_offset=$(( (diff/2)+(diff%2) ))

            # The code below attempts to display the previously
            # visible lines in the middle of the scroll area
            # with the remaining space filled with available
            # lines from file

            # If there arent enough lines in the file above
            # y_start to cover the top region
            if (( y_start <= top_offset )); then
                y_start=0
                y_end=$((y_end+top_offset))

            # If there are enough lines in the file above
            # y_start to cover the top region
            else
                y_start=$((y_start-top_offset))
            fi

            y_end=$((y_end+bot_offset))

            scroll_y=$((y-y_start+1))
        }

        # If the files length is smaller than scroll area
        (( total_lines <= max_lines )) && {
            y_start=0
            y_end=$((max_lines))
            scroll_y=$((y+1))
        }
    fi


    for ((i=y_start;i<y_end;i++)); do
            draw_line "$i"
            (( i+1 < y_end )) && printf "\n"
    done
}

sync_cursor() {
    # If curr_x is greater than the length of the current y'th line
    # The value of x is set to the end of the line
    if (( curr_x >= ${#file_data[y]} )); then
        x=$((${#file_data[y]}-1))

    # If curr_x is smaller than or equal to the length
    # of the current y'th line
    else
        x=$curr_x
    fi

    if (( x < (COLUMNS-2) || ${#file_data[y]} <= COLUMNS )); then
        scroll_x=$((x+1))
    else
        local p=$(( (x-COLUMNS+2) / (COLUMNS-5) ))
        local x_start=$(( (p*(COLUMNS-5) ) + (COLUMNS-2) ))
        local x_end=$(( x_start+COLUMNS-5 ))

        scroll_x=$(( x-x_start+4 ))
    fi

    # move cursor to position scroll_x,scroll_y
    printf '\e[%s;%sH' "$scroll_y" "$scroll_x"

}

redraw() {
    clear_screen
    draw_page
    sync_cursor
    status_line
}

# Text Navigation
###############################################################################
move_up () {
    # '\e[1L' : Insert a line above the cursor.
    # '\e[A'  : Move cursor up a line.
    # '\e[2K' : Clear current line
    (( y >= 1 )) && {
        x=0
        draw_line
        x=$curr_x

        ((y--))

        if (( scroll_y > 1 )); then
            ((scroll_y--))
            printf '\e[A\e2K'
        else
            printf '\e[1L'
            ((y_start--))
            ((y_end--))
        fi

        draw_line
        sync_cursor
        status_line
    }
}

move_down () {
    # '\e[B'  : Move cursor down a line.
    # '\e[2K' : Clear current line
    (( y+1 < total_lines )) && {
        x=0
        draw_line
        x=$curr_x

        ((y++))

        if (( scroll_y < max_lines )); then
            ((scroll_y++))
            printf '\e[B\e[2K'
        else
            printf '\n'
            ((y_start++))
            ((y_end++))
        fi

        draw_line
        sync_cursor
        status_line
    }
}

move_left () {
    if (( x > 0 )); then
        ((x--))
        curr_x=$x
        draw_line
        sync_cursor
        status_line
    else
        x=$(( ${#file_data[y-1]}-1 ))
        curr_x=$x
        move_up
    fi
}

move_right () {
    if (( x+1 < ${#file_data[y]} )); then
        ((x++))
        curr_x=$x
        draw_line
        sync_cursor
        status_line
    elif (( y+1 < total_lines )); then
        x=0
        curr_x=$x
        move_down
    fi
}

# Text Modification
###############################################################################
insert_character () {
    file_data[$y]="${file_data[y]::x}$1${file_data[y]:x}"
    ((x++))
    curr_x=$x
}

insert_newline () {

    # Inserting additional line
    file_data=( "${file_data[@]::y}" \
                "${file_data[y]::x} " \
                "${file_data[y]:x}" \
                "${file_data[@]:y+1}" )

    ((y++))
    ((x=0))
    ((curr_x=0))
    ((total_lines++))

    # Incase newline is invoked at the bottom of the scroll region
    # push everything up one line and print the generated newline
    (( scroll_y == max_lines )) && {
        draw_line "$((y-1))"
        printf '\n'
        draw_line
    }

    # Incase newline is invoked anywhere else in the scroll region
    # push everything below the cursor down one line
    # and print the generated newline
    (( scroll_y < max_lines )) && {
        draw_line
        printf '\e[1L'
        draw_line "$((y-1))"
        ((scroll_y++))
    }
}

bckspc () {

    # If backspace is used at the start of the line
    (( x == 0 )) && {
        (( y < 1 )) && return;

        ((x=${#file_data[y-1]}-1))
        ((curr_x=${#file_data[y-1]}-1))

        file_data=( "${file_data[@]::y-1}" \
                    "${file_data[y-1]::-1}${file_data[y]}" \
                    "${file_data[@]:y+1}" )

        ((y--))
        ((total_lines--))

        # If used on the first line of the terminal
        (( scroll_y == 1 )) && {
            printf '\e2K'
            draw_line
        }

        # If used anywhere else. The content below the line
        # where the cursor is would need to be shifted up a line
        (( scroll_y > 1 )) && {
            ((scroll_y--))
            printf '\e[A'

            for ((i=0; i<=max_lines-scroll_y; i++)); do
                draw_line "$((y+i))"
                (( i < max_lines-scroll_y )) && printf "\n"
            done
        }

        return
    }

    # If backspace is used anywhere else
    (( x > 0 )) && {

        file_data[y]="${file_data[y]::x-1}${file_data[y]:x}"

        ((x--))
        ((curr_x=x))
        printf '\e2K'
        draw_line
        return
    }

}

delete_key () {

    # if delete is used at the end of the line
    (( x == ${#file_data[y]}-1 )) && {
        ((curr_x=x))

        (( y == total_lines-1 )) && return;

        file_data=( "${file_data[@]::y}" \
                    "${file_data[y]::-1}${file_data[y+1]}" \
                    "${file_data[@]:y+2}" )

        ((total_lines--))

        # if used at the last line of the scroll region
        (( scroll_y == max_lines )) && {
            printf '\e2K'
            draw_line
        }

        # If used anywhere else. The content below the line
        # where the cursor is would need to be shifted up a line
        (( scroll_y < max_lines )) && {
            printf '\e2K'

            for ((i=0; i<=max_lines-scroll_y; i++)); do
                draw_line "$((y+i))"
                (( i < max_lines-scroll_y )) && printf "\n"
            done
        }

        return
    }

    # if delete is used anywhere else
    (( x < ${#file_data[y]}-1 )) && {
        file_data[y]="${file_data[y]::x}${file_data[y]:x+1}"

        ((curr_x=x))
        printf '\e2K'
        draw_line
        return
    }
}

# File Handling
###############################################################################
check_file() {

    local link_path

    [[ ! -a "$*" ]] && printf "%s\n" "[ERR] File $* does not exist" && exit

    [[ ! -r $* ]] && printf "%s\n" "[ERR] File $* can't be read" && exit

    [[ -d $* ]] && printf "%s\n" "[ERR] File $* is a directory" && exit

    [[ -h $* && -e $* ]] && {
        link_path=$( readlink -f "$*" )
        check_file "${link_path// /\\ }"
        return
    }

    file=$( readlink -f "$*" )
}

read_file() {

    # Bash 4+
    [[ -n $file ]] && mapfile -t file_data < "$file"

    (( ${#file_data[*]} == 0 )) && {
        file_data=( "" )
    }

    # file line count
    total_lines="${#file_data[*]}"

    # Adding a ' ' to the end of each line to allow
    # editing the last character of a line. The cursor
    # always stays ahead of the point where it modifies
    # Hence to modify the contextually last character of line
    # A ' ' needs to be introduced at the end.
    for (( i=0;i<total_lines;i++ ));do
        file_data[$i]+=" "
    done
}

# Main Functions
###############################################################################
key() {
    local special_keys

    [[ $1 == $'\e' ]] && {
        special_keys+=${1}

        # \e A
        # \e [ A
        # \e [ 6 ~
        # \e [ 2 0 ~
        # \e [ 1 ; 5~
        # \e [ 1 ; 5C
        # -- - - - --
        #  1 2 3 4 5

        #* read 2
        read "${read_flags[@]}" -srn 1
        special_keys+=${REPLY}

        [[ $REPLY == $'[' ]] && {
            #* read 3
            read "${read_flags[@]}" -srn 1
            special_keys+=${REPLY}

            [[ ${REPLY} == [0-9] ]] && {
                #* read 4
                read "${read_flags[@]}" -srn 1
                special_keys+=${REPLY}

                [[ ${REPLY} == [[:digit:]] ]] && {
                    read "${read_flags[@]}" -srn 1 _
                    special_keys+="~"
                }

                [[ ${REPLY} == ";" ]] && {
                    read "${read_flags[@]}" -srn 2
                    special_keys+=${REPLY}
                }
            }
        }

    }

    case "${special_keys:-$1}" in

        # Text Navigation
        #-=========================================

        # Move Cursor Right
        # 'C' is what bash sees when the right arrow is pressed
        # ('\e[C' or '\eOC').
        "${SCROLL_RIGHT1:=$'\e[C'}"|\
        "${SCROLL_RIGHT2:=$'\eOC'}")
            move_right
        ;;

        # Move Cursor Left
        # 'D' is what bash sees when the left arrow is pressed
        # ('\e[D' or '\eOD').
        "${SCROLL_LEFT1:=$'\e[D'}"|\
        "${SCROLL_LEFT2:=$'\eOD'}")
            move_left
        ;;

        # Scroll up.
        # 'A' is what bash sees when the up arrow is pressed
        # ('\e[A' or '\eOA').
        "${SCROLL_UP2:=$'\e[A'}"|\
        "${SCROLL_UP3:=$'\eOA'}")
            move_up
        ;;

        # Scroll down.
        # 'B' is what bash sees when the down arrow is pressed
        # ('\e[B' or '\eOB').
        "${SCROLL_DOWN2:=$'\e[B'}"|\
        "${SCROLL_DOWN3:=$'\eOB'}")
            move_down
        ;;

        # Go up one page
        "${PGUP:=$'\E[5~'}")
            ((x=0))
            ((curr_x=0))

            (( y != 0 )) && {
                if (( y_start == 0 )); then
                    ((y=0))
                    ((scroll_y=1))
                elif (( y_start >= max_lines )); then
                    (( y_end=y_start ))
                    (( y_start=y_start-max_lines ))
                    (( y=y_start+scroll_y-1 ))
                elif (( y_start <= max_lines )); then
                    (( y_start=0 ))
                    (( y_end=max_lines ))

                    (( y-max_lines < 0 )) && {
                        (( y=0 ))
                        (( scroll_y=1 ))
                    }

                    (( y-max_lines >= 0 )) && {
                        (( y=y-max_lines ))
                        (( scroll_y=y+1 ))
                    }
                fi

                redraw
            }
        ;;

        # Go down one page
        "${PGDWN:=$'\E[6~'}")
            ((x=0))
            ((curr_x=0))

            (( y != total_lines-1 )) && {
                if (( y_end >= total_lines )); then
                    (( y=total_lines-1 ))
                    (( scroll_y=total_lines-y_start))
                elif (( y_end+max_lines <= total_lines )); then
                    (( y_start=y_end ))
                    (( y_end=y_start+max_lines ))
                    (( y=y+max_lines ))
                else
                    (( y_start=y_end ))
                    (( y_end=y_start+max_lines ))

                    (( y_start+scroll_y-1 >= total_lines )) && {
                        (( y=total_lines-1 ))
                        (( scroll_y=total_lines-y_start))
                    }

                    (( y_start+scroll_y-1 < total_lines )) && {
                        (( y=y_start+scroll_y-1 ))
                    }
                fi

                redraw
            }
        ;;

        # Move to start of line
        "${HOME_KEY:=$'\E[1~'}")
            ((x=0))
            ((curr_x=0))
            draw_line
            sync_cursor
            status_line
        ;;

        # Move to end of line
        "${END_KEY:=$'\E[4~'}")
            ((x=${#file_data[y]}))
            ((curr_x=${#file_data[y]}))
            draw_line
            sync_cursor
            status_line
        ;;

        # Text Editing
        #-=========================================

        # TO instert a newline in the text
        "${NEWLINE:=""}")
            insert_newline
            sync_cursor

            MODIFIED=1
            status_line
        ;;

        # Backspace to remove a character before the cursor
        "${BCKSPC1:=$'\b'}"|\
        "${BCKSPC2:=$'\177'}")
            bckspc
            sync_cursor
            MODIFIED=1
            status_line
        ;;

        # Delete key to remove the character under the cursor
        "${DELETE_KEY:=$'\e[3~'}")
            delete_key
            sync_cursor
            MODIFIED=1

            status_line
        ;;

        # A-Z , a-z , 0-9 and special charcters to insert into
        # the text
        [[:alnum:]] |\
        [[:punct:]] |\
        " ")
            insert_character "$1"
            printf '\e2K'
            draw_line
            sync_cursor
            MODIFIED=1
            status_line
        ;;

        # Editor Functionality
        #-=========================================

        # F5 key to redraw the current screen
        # Used for debug purposes
        "${REDRAW:=$'\E[15~'}")
            redraw
        ;;

        # Ctrl+x to quit
        "${QUIT_KEY:=$'\030'}")
            exit
        ;;

    esac
}

init_vars() {
    # setting up variables for position within file
    #
    # x         : Denotes the point at which the element is being modififed
    # y         : Denotes which element in file_data is being modified
    # scroll_x  : Denotes the COLUMN wise position of the cursor
    #             within the terminal
    # scrol_y   : Denotes the ROW wise position of the cursor
    #             within the terminal
    # curr_x    : This variable is used to denote the farthest the cursor
    #             has been from the right hand side of the terminal. This
    #             is used while moving up and down a line.
    #             (It gets overwritten when moving left or right)
    #             (Used in draw_page)
    # y_start   : Denotes the y value of the line from which a page starts
    # y_end     : Similar to y_start, y_end denotes the y value of the line
    #             at the end of the page
    # MODIFIED  : Acts as a flag to show if the file/buffer has been modified
    #             in any way or form

    x=0
    y=0
    scroll_x=1
    scroll_y=1

    curr_x=0

    y_start=0
    y_end=$max_lines

    MODIFIED=0
}

main() {
    [[ $1 == -v ]] && {
        printf '%s\n' "BTE 0.1"
        exit
    }

    # Check to see of a file name has been passsed
    if [[ -n $* ]]; then
        check_file "$*"
    fi

    # load file onto array file_data
    read_file

    # To stop read from waiting indefinetly for a character input
    read_flags=(-t 0.05)

    # Trap the exit signal (we need to reset the terminal to a useable state.)
    trap 'reset_terminal' EXIT

    # Trap the window resize signal (handle window resize events).
    trap 'get_term_size; redraw' WINCH

    get_term_size
    init_vars
    setup_terminal
    redraw

    # Vintage infinite loop.
    for ((;;)); {
        read "${read_flags[@]}" -srn 1 && key "$REPLY"

        # Exit if there is no longer a terminal attached.
        [[ -t 1 ]] || exit 1
    }
}

main "$@"